
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_LITE_BEE271Lab4(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
// start by perssing KEY[0]
// fixed or variable delay resets it
reg[31:0] CDIV;	// define 32-bit counter
wire DCLK, NCLK, CRES;			// clock output to other modules
always@(*)begin	// start always block
	if (DCLK == 0) CDIV = 0;	//if CLK was off, reset counter
	else CDIV = CDIV + 1;		//otherwise count up
	end								//end clock counter
assign CRES = CDIV[28];
assign DCLK = ~(KEY[1] & NCLK);
assign NCLK = ~(CRES & DCLK);

// Clock Generator
reg Clk;
reg ACLK;
reg [25:0] SCLK, SMAX;
always @(*) begin
	case(SW[7:6])
	2'b00: SMAX <= 25000000;// 1hz from 50 MHz Clock
	2'b01: SMAX <= 250000;	// 100 Hz
	2'b10: SMAX <= 2500;	// 10 kHz
	2'b11: SMAX <= 25;		// 1	MHz
	endcase
	end
always @(posedge MAX10_CLK1_50) begin
SCLK = SCLK-1;	//countdown
if (SCLK == 0) begin
		SCLK <= SMAX;	//reload
		ACLK <= ~ACLK;	//flip output
end	//end clock divider
end	//end clock always block

always @(*)begin
	if (SW[8]) Clk <= ACLK; // automatic clock
	else Clk <= DCLK;	// manual clock
end

//=======================================================
//  Structural coding
//=======================================================

// FSM Inputs: Clock, Reset, Step
// manual FSM counter Reset
wire SecRes, MinRes, HRRes, DayRes, MonRes, YRRes;
assign SecRes = ~KEY[0];	// reset off Key[0]
//	step wires;
wire SecStep, MinStep, HRStep, DayStep, MonStep, YRStep, CStep; //No centuries
// Time Variables
wire [7:0] Sec, Min, HR, Day, Mon, YR;
assign SecStep = 1;

reg[7:0] DayMax;

always @(DayMax) begin
case(Mon)
	4'b0001, 4'b0011, 4'b0101, 4'b0110, 4'b0111, 4'b1001, 4'b1100: DayMax = 'h31;	//	31 days JAN, MAR, MAY, JUL, AUG, OCT, DEC
	4'b0010: if(YR % 4 == 0) DayMax = 'h29;	// 29 Leap Year FEB
		else DayMax = 'h28;		//	28 days in other years
	4'b0100, 4'b0110: DayMax = 'h30; // 30 days APR, JUN, SEP, NOV
endcase
end

ClockCal SEC(Clk, SecRes, SecStep, 'h00, 'h59, Sec, MinStep);// seconds
ClockCal MIN(Clk, MinRes, MinStep, 'h00, 'h59, Min, HRStep); // minutes
ClockCal HOUR(Clk, HRRes, HRStep, 'h00, 'h23, HR, DayStep); // hours
ClockCal DAY(Clk, DayRes, DayStep, 'h01, DayMax, Day, MonStep); //Days
ClockCal MON(Clk, MonRes, MonStep, 'h01, 'h12, Mon, YRStep);	// months (1-12)
ClockCal YEAR(Clk, YRRes, YRStep, 'h00, 'h99, YR, CStep);	// years

//Two-Set Displays (Superifically Complex)
reg [7:0] LD, MD, RD;
always @(*)
if(SW[9]) begin LD = YR; MD = Mon; RD = Day; end
else begin LD = HR; MD = Min; RD = Sec; end

Seg7 digit0(RD[3:0],HEX0);
Seg7 digit1(RD[6:4],HEX1);
Seg7 digit2(MD[3:0],HEX2);
Seg7 digit3(MD[6:4],HEX3);
Seg7 digit4(LD[3:0],HEX4);
Seg7 digit5(LD[6:4],HEX5);

assign LEDR[0] = SecStep;
assign LEDR[1] = MinStep;
assign LEDR[2] = HRStep;
assign LEDR[3] = DayStep;
assign LEDR[4] = MonStep;
assign LEDR[5] = YRStep;
assign LEDR[9] = Clk;

endmodule

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//	Sample Manual Clock
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
module ClockCal(
	input Clk, Reset, Step,
	input [7:0] Vmin, Vmax,	// Value Ranges
	output reg [7:0] CV,		// Current Value
	output reg NStep);		// Output Next Step
reg [7:0] TV;
reg [3:0] TVL;
always @(posedge Clk) begin
	if(Reset) TV = Vmin;		//If Reset, Reload
	else if(Step) begin
		TV <= CV+1;
		// Defer BCD Test
		TVL <= TV & 4'b1111;			 // clip 4 bits
		if (TVL == 8) TV <= TV + 7; // if time, increment next digit
		if (TV == Vmax) TV <= Vmin;	// If @ Max, Reset
		end									//End count
	end									//End + always block
always @(negedge Clk) CV <= TV; // copy back out
always @(*)
	if (Step && CV == Vmax) NStep = 1;
	else NStep = 0;
endmodule	//end of clockcal

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//	7 Segment Display 4-Switch Assignment
// @Lab 1
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

module Seg7 (hex, Seg);
input wire [3:0] hex;
output wire [6:0] Seg;

assign x0 = hex[0];
assign x1 = hex[1];
assign x2 = hex[2];
assign x3 = hex[3];

assign Seg[0]= ~(x1 & x2 | ~x1 & ~x2 & x3 | ~x0 & x3 | ~x0 & ~x2 | 
	x0 & x2 & ~x3 | x1 & ~x3);
assign Seg[1]= ~(~x0 & ~x2 | ~x2 & ~x3 | x0 & x1 & ~x3 | ~x0 & ~x1 & ~x3 |
	x0 & ~x1 & x3);
assign Seg[2]=	~(~x1 & ~x3 | x0 & ~x3 | x0 & ~x1 | x2 & ~x3 | ~x2 & x3);
assign Seg[3]=	~(x2 & ~x1 & x0 | ~x2 & x1 & x0 | ~x3 & ~x2 & ~x0 |
	x2 & x1 & ~x0 | x3 & ~x1 & ~x0);
assign Seg[4]=	~(~x0 & ~x2 | ~x0 & x1 | x2 & x3 | x1 & x3);
assign Seg[5]=	~(~x0 & ~x1 | ~x1 & x2 & ~x3 | ~x0 & x2 | x1 & x3 | ~x2 & x3);
assign Seg[6]=	~(~x2 & x1 | x3 & ~x2 | ~x3 & x2 & ~x1 | x1 & ~x0 | x3 & x0);
endmodule //Seg7